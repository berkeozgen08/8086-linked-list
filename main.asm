
STACKSG SEGMENT PARA STACK 'STACK'
	DW 40 DUP(?)
STACKSG ENDS

DATASG SEGMENT PARA 'DATA'
	MENU_MESSAGE DB "MAIN MENU", 10, "0 - QUIT", 10, "1 - ADD MULTIPLE VALUES TO LINKED LIST", 10, "2 - PRINT LINKED LIST", 10, "3 - ADD A VALUE TO LINKED LIST", 10, "CHOICE: ", 0
	MENU_ERROR_MESSAGE DB "INCORRECT CHOICE. TRY AGAIN.", 10, 0
	MENU_1_MESSAGE DB "VALUE COUNT: ", 0
	MENU_3_MESSAGE DB "NEW VALUE: ", 0
	INPUT_NUM_ERROR_MESSAGE DB "YOU DID NOT ENTER A NUMBER. TRY AGAIN.", 10, 0
	ADD_TO_LL_ERROR_MESSAGE DB "LINKED LIST IS FULL.", 10, 0
	ADD_MANY_TO_LL_MESSAGE DB ". VALUE: ", 0
	ADD_MANY_TO_LL_ERROR DB "VALUE COUNT CANNOT BE NEGATIVE.", 10, 0
	PRINT_LL_MESSAGE1 DB "VALUES", 10, 0
	PRINT_LL_MESSAGE2 DB "LINKS", 10, 0
	PRINT_LL_MESSAGE3 DB "MINIMUM INDEX", 10, 0
	PRINT_LL_MESSAGE4 DB "LINKED LIST", 10, 0
	PRINT_LL_SPACE DB "  ", 0
	PRINT_LL_ARROW DB " -> ", 0
	PRINT_LL_ERROR_MESSAGE DB "LINKED LIST IS EMPTY.", 10, 0
	LL_DATA DW 100 DUP(?)
	LL_LINKS DW 100 DUP(?)
	LL_LENGTH DW 0
	LL_MIN DW 0
DATASG ENDS

CODESG SEGMENT PARA 'CODE'
	ASSUME CS:CODESG, DS:DATASG, SS:STACKSG

MAIN PROC FAR
	PUSH DS
	XOR AX, AX
	PUSH AX
	MOV AX, DATASG
	MOV DS, AX
	
	; Print menu and go to sub menus based on the given input
MENU_LOOP:
	MOV AX, OFFSET MENU_MESSAGE
	CALL PRINT_STR
	CALL INPUT_NUM
	CMP AL, 0
	JE END_PROGRAM
	CMP AL, 1
	JE MENU_1_LOOP
	CMP AL, 2
	JE MENU_2_LOOP
	CMP AL, 3
	JE MENU_3_LOOP
	MOV AX, OFFSET MENU_ERROR_MESSAGE
	CALL PRINT_STR
	JMP MENU_LOOP

MENU_1_LOOP:
	MOV AX, OFFSET MENU_1_MESSAGE
	CALL PRINT_STR
	CALL INPUT_NUM
	CALL ADD_MANY_TO_LL
	JMP MENU_LOOP
	
MENU_2_LOOP:
	CALL PRINT_LL
	JMP MENU_LOOP
	
MENU_3_LOOP:
	MOV AX, OFFSET MENU_3_MESSAGE
	CALL PRINT_STR
	CALL INPUT_NUM
	CALL ADD_TO_LL
	JMP MENU_LOOP
	
END_PROGRAM:
	RETF
MAIN ENDP



; Print contents of AL
PRINT_CHAR PROC NEAR
	PUSH DX
	PUSH AX
	
	MOV DL, AL
	MOV AH, 02H
	INT 21H
	
	POP AX
	POP DX
	RET
PRINT_CHAR ENDP



; Print a newline character
PRINT_NEWLINE PROC NEAR
	PUSH AX
	
	MOV AL, 10
	CALL PRINT_CHAR
	
	POP AX
	RET
PRINT_NEWLINE ENDP



; Print a string whose address is given by AX
PRINT_STR PROC NEAR
	PUSH BX
	
	MOV BX, AX
PRINT_STR_LOOP:
	MOV AL, [BX]
	CMP AL, 00H
	JE PRINT_STR_END
	CALL PRINT_CHAR
	INC BX
	JMP PRINT_STR_LOOP
	
PRINT_STR_END:
	POP BX
	RET
PRINT_STR ENDP



; Print the number in AX
PRINT_NUM PROC NEAR
	PUSH CX
	PUSH DX
	
	; End popping with 00h
	XOR CX, CX
	PUSH CX
	; Multiplier
	MOV CX, 10
	
	; If negative then print '-' and negate
	CMP AX, 0
	JGE PRINT_NUM_PUSH
	PUSH AX
	MOV AL, '-'
	CALL PRINT_CHAR
	POP AX
	NEG AX
	
PRINT_NUM_PUSH:
	; Divide number by 10, DX: AX%10, AX: AX/10
	XOR DX, DX
	DIV CX
	ADD DX, '0'
	; Push ASCII number to stack to pop and print from the opposite order
	PUSH DX
	; Continue until number hits 0
	CMP AX, 0
	JNZ PRINT_NUM_PUSH
	JMP PRINT_NUM_POP

	; Pop and print
PRINT_NUM_POP:
	POP AX
	CMP AX, 0
	JZ PRINT_NUM_END
	CALL PRINT_CHAR
	JMP PRINT_NUM_POP

PRINT_NUM_END:
	POP DX
	POP CX
	RET
PRINT_NUM ENDP



; Reads a character to AL
INPUT_CHAR PROC NEAR
	MOV AH, 01H
	INT 21H
	RET
INPUT_CHAR ENDP



; Reads a number to AX
INPUT_NUM PROC NEAR
	PUSH DX
	PUSH BX
	PUSH CX
	
INPUT_NUM_START:
	; Negative flag
	MOV DL, 0
	; Digit value
	XOR BX, BX
	; Accumulated number
	XOR CX, CX
	
	; If first character is negative, DL <- 1
	CALL INPUT_CHAR
	CMP AL, '-'
	JNE INPUT_NUM_LOOP
	MOV DL, 1
	JMP INPUT_NUM_NEGATIVE
	
INPUT_NUM_LOOP:
	; If Enter is pressed, branch
	CMP AL, 13
	JE INPUT_NUM_ENTER
	; If input not a digit, branch
	CMP AL, '0'
	JB INPUT_NUM_ERROR
	CMP AL, '9'
	JA INPUT_NUM_ERROR

	SUB AL, '0'
	XOR AH, AH
	PUSH AX
	PUSH DX
	; Multiply CX by 10, abc -> abc0
	MOV DX, 10
	MOV AX, CX
	MUL DX
	MOV CX, AX
	POP DX
	POP AX
	; Add number to the accumulated value, abc0 -> abcd
	ADD CX, AX
	INC BX
INPUT_NUM_NEGATIVE:
	CALL INPUT_CHAR
	JMP INPUT_NUM_LOOP
	
	; Restart proc if there was an error
INPUT_NUM_ERROR:
	CALL PRINT_NEWLINE
	MOV AX, OFFSET INPUT_NUM_ERROR_MESSAGE
	CALL PRINT_STR
	JMP INPUT_NUM_START

	; Throw error if Enter was the first button that was pressed
INPUT_NUM_ENTER:
	CMP BX, 0
	JE INPUT_NUM_ERROR
	
	; If input was given as negative then negate
	CMP DL, 0
	JZ INPUT_NUM_END
	NEG CX
	
INPUT_NUM_END:
	MOV AX, CX
	POP CX
	POP BX
	POP DX
	RET
INPUT_NUM ENDP



; Add data with value AX to the linked list
ADD_TO_LL PROC NEAR
	; Throw error and end proc if the linked list is full
	CMP LL_LENGTH, LENGTH LL_DATA
	JNE ADD_TO_LL_START
	MOV AX, OFFSET ADD_TO_LL_ERROR_MESSAGE
	CALL PRINT_STR
	JMP ADD_TO_LL_ERROR
	
ADD_TO_LL_START:
	PUSH SI
	PUSH DI
	PUSH BX
	
	; If the number is the first value to be entered to the linked list
	; then set its link to -1 and branch
	CMP LL_LENGTH, 0
	JNZ ADD_TO_LL_NOT_EMPTY
	MOV LL_LINKS[0], -1
	JMP ADD_TO_LL_END
	
ADD_TO_LL_NOT_EMPTY:
	MOV SI, LL_MIN
	SHL SI, 1
	; If the number is smaller than the current minimum
	; then set it as the new minimum
	CMP AX, LL_DATA[SI]
	JG ADD_TO_LL_LOOP
	MOV BX, LL_LENGTH
	MOV LL_MIN, BX
	SHL BX, 1
	SHR SI, 1
	MOV LL_LINKS[BX], SI
	JMP ADD_TO_LL_END

	; Start checking if the number is smaller than the values starting from the 2nd minimum
ADD_TO_LL_LOOP:
	; Keep track of the previous index
	MOV DI, SI
	; Next index
	MOV SI, LL_LINKS[SI]
	; Continue until the last value
	CMP SI, -1
	JE ADD_TO_LL_LINK
	SHL SI, 1
	; Value at the next index
	MOV BX, LL_DATA[SI]
	; Continue while the number is greater than the values
	CMP AX, BX
	JG ADD_TO_LL_LOOP
	
	; Link the number to the next index, link the previous index to the number
ADD_TO_LL_LINK:
	MOV BX, LL_LENGTH
	MOV LL_LINKS[DI], BX
	SHL BX, 1
	SAR SI, 1
	MOV LL_LINKS[BX], SI
	
	; Save the number to the values
ADD_TO_LL_END:
	MOV BX, LL_LENGTH
	SHL BX, 1
	MOV LL_DATA[BX], AX
	INC LL_LENGTH
	POP BX
	POP DI
	POP SI
ADD_TO_LL_ERROR:
	RET
ADD_TO_LL ENDP



; Construct the linked list with length AX
ADD_MANY_TO_LL PROC NEAR
	; If given length is 0 then end proc
	CMP AX, 0
	JZ ADD_MANY_TO_LL_END
	JG ADD_MANY_TO_LL_START
	MOV AX, OFFSET ADD_MANY_TO_LL_ERROR
	CALL PRINT_STR
	JMP ADD_MANY_TO_LL_END
	
ADD_MANY_TO_LL_START:
	PUSH CX
	
	; Take input and add to the linked list for AX times
	MOV CX, AX
	MOV AX, 1
ADD_MANY_TO_LL_LOOP:
	PUSH AX
	CALL PRINT_NUM
	MOV AX, OFFSET ADD_MANY_TO_LL_MESSAGE
	CALL PRINT_STR
	CALL INPUT_NUM
	CALL ADD_TO_LL
	POP AX
	INC AX
	LOOP ADD_MANY_TO_LL_LOOP

	POP CX
ADD_MANY_TO_LL_END:
	RET
ADD_MANY_TO_LL ENDP



; Print linked list
PRINT_LL PROC NEAR
	; If length is 0, print error and end proc
	CMP LL_LENGTH, 0
	JNZ PRINT_LL_START
	MOV AX, OFFSET PRINT_LL_ERROR_MESSAGE
	CALL PRINT_STR
	JMP PRINT_LL_ERROR

PRINT_LL_START:
	PUSH SI
	PUSH AX
	
	; Print the contents of the data array
	MOV AX, OFFSET PRINT_LL_MESSAGE1
	CALL PRINT_STR
	MOV CX, LL_LENGTH
	XOR SI, SI
PRINT_LL_DATA_LOOP:
	MOV AX, LL_DATA[SI]
	CALL PRINT_NUM
	MOV AX, OFFSET PRINT_LL_SPACE
	CALL PRINT_STR
	ADD SI, 2
	LOOP PRINT_LL_DATA_LOOP
	CALL PRINT_NEWLINE
	
	; Print the contents of the links array
	MOV AX, OFFSET PRINT_LL_MESSAGE2
	CALL PRINT_STR
	MOV CX, LL_LENGTH
	XOR SI, SI
PRINT_LL_LINKS_LOOP:
	MOV AX, LL_LINKS[SI]
	CALL PRINT_NUM
	MOV AX, OFFSET PRINT_LL_SPACE
	CALL PRINT_STR
	ADD SI, 2
	LOOP PRINT_LL_LINKS_LOOP
	CALL PRINT_NEWLINE
	
	MOV AX, OFFSET PRINT_LL_MESSAGE3
	CALL PRINT_STR
	MOV AX, LL_MIN
	CALL PRINT_NUM
	CALL PRINT_NEWLINE
	
	; Print the linked list in form x -> y -> z
	MOV AX, OFFSET PRINT_LL_MESSAGE4
	CALL PRINT_STR
	MOV SI, LL_MIN
PRINT_LL_LOOP:
	CMP SI, -1
	JE PRINT_LL_END
	SHL SI, 1
	MOV AX, LL_DATA[SI]
	CALL PRINT_NUM
	MOV SI, LL_LINKS[SI]
	CMP SI, -1
	JE PRINT_LL_END
	MOV AX, OFFSET PRINT_LL_ARROW
	CALL PRINT_STR
	JMP PRINT_LL_LOOP
	
PRINT_LL_END:
	CALL PRINT_NEWLINE
	POP AX
	POP SI
PRINT_LL_ERROR:
	RET
PRINT_LL ENDP



CODESG ENDS
	END MAIN